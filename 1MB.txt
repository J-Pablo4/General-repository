En informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M

n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M
n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M

n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M

n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M
n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M

n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M

n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M

n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
La ventaja fundamental de esta arquitectura es que permite adecuar el tamaño de los buses a las características de cada tipo de memoria; además, el procesador puede acceder a cada una de ellas de forma simultánea, lo que se traduce en un aumento significativo de la velocidad de procesamiento. Típicamente los sistemas con esta arquitectura pueden ser dos veces más rápidos que sistemas similares con arquitectura Von Neumann.
La desventaja está en que consume muchas líneas de E/S del procesador; por lo que en sistemas donde el procesador está ubicado en su propio encapsulado, solo se utiliza en supercomputadoras. Sin embargo, en los microcontroladores y otros sistemas integrados, donde usualmente la memoria de datos y programas comparten el mismo encapsulado que el procesador, este inconveniente deja de ser un problema serio y es por ello que encontramos la arquitectura Harvard en la mayoría de los microcontroladores.
Por eso es importante recordar que un microcontrolador se puede configurar de diferentes maneras, siempre y cuando se respete el tamaño de memoria que este requiera para su correcto funcionamiento.
Procesador en detalle[editar]
En los años 1970, la electrónica digital no estaba suficientemente desarrollada, pero dentro de la electrónica ya era una especialidad consagrada. En aquel entonces las computadoras se diseñaban para que realizaran algunas operaciones muy simples, y si se quería que estas máquinas pudiesen hacer cosas diferentes, era necesario realizar cambios bastante significativos al hardware.
A principios de la década de 1970, una empresa japonesa le encargó a una joven compañía norteamericana que desarrollara un conjunto de circuitos para producir una calculadora de bajo costo. Intel se dedicó de lleno a la tarea y entre los circuitos encargados desarrolló uno muy especial, algo no creado hasta la fecha: el primer microprocesador integrado.
El Intel 4004 salió al mercado en 1971, es una máquina digital sincrónica compleja, como cualquier otro circuito lógico secuencial sincrónico. Sin embargo, la ventaja de este componente está en que aloja internamente un conjunto de circuitos digitales que pueden hacer operaciones corrientes para el cálculo y procesamiento de datos, pero desde una óptica diferente: sus entradas son una serie de códigos bien definidos, que permiten hacer operaciones de carácter específico cuyo resultado está determinado por el tipo de operación y los operandos involucrados.
Visto así, no hay nada de especial en un microprocesador; la maravilla está en que la combinación adecuada de los códigos de entrada, su ejecución secuencial, el poder saltar hacia atrás o adelante en la secuencia de códigos sobre la base de decisiones lógicas u órdenes específicas, permite que la máquina realice gran cantidad de operaciones complejas, no contempladas en los simples códigos básicos.
Hoy estamos acostumbrados a los sistemas con microprocesadores, pero en el lejano 1971 esta era una forma de pensar un poco diferente y hasta escandalosa, a tal punto que Busicom, la empresa que encargó los chips a Intel, no se mostró interesada en el invento, por lo que Intel lo comercializó para otros que mostraron interés; el resto es historia: una revolución sin precedentes en el avance tecnológico de la humanidad.
Es lógico pensar que el invento del microprocesador integrado no fue una revelación divina para sus creadores, sino que se sustentó en los avances, existentes hasta el momento, en el campo de la electrónica digital y las teorías sobre computación. Pero sin lugar a dudas fue la gota que colmó la copa de la revolución científico-técnica, porque permitió desarrollar aplicaciones impensadas o acelerar algunas ya encaminadas.
Ahora comenzaremos a ver cómo es que está hecho un procesador, no será una explicación demasiado detallada porque desde su invención este ha tenido importantes revoluciones propias, pero hay aspectos básicos que no han cambiado y que constituyen la base de cualquier microprocesador. En la Figura 'Esquema de un microcontrolador' podemos ver la estructura típica de un microprocesador, con sus componentes fundamentales, claro está que ningún procesador real se ajusta exactamente a esta estructura, pero aun así nos permite conocer cada uno de sus elementos básicos y sus interrelaciones.
Registros[editar]
Artículo principal: Registro (hardware)
Son un espacio de memoria muy reducido pero necesario para cualquier microprocesador, de aquí se toman los datos para varias operaciones que debe realizar el resto de los circuitos del procesador. Los registros sirven para almacenar los resultados de la ejecución de instrucciones, cargar datos desde la memoria externa o almacenarlos en ella.
Aunque la importancia de los registros parezca trivial, no lo es en absoluto. De hecho una parte de los registros, la destinada a los datos, es la que determina uno de los parámetros más importantes de cualquier microprocesador. Cuando escuchamos que un procesador es de 4, 8, 16, 32 o 64 bits, nos estamos refiriendo a procesadores que realizan sus operaciones con registros de datos de ese tamaño, y por supuesto, esto determina muchas de las potencialidades de estas máquinas.
Mientras mayor sea el número de bits de los registros de datos del procesador, mayores serán sus prestaciones, en cuanto a poder de cómputo y velocidad de ejecución, ya que este parámetro determina la potencia que se puede incorporar al resto de los componentes del sistema, por ejemplo, no tiene sentido tener una ALU de 16 bits en un procesador de 8 bits.
Por otro lado un procesador de 16 bits, puede que haga una suma de 16 bits en un solo ciclo de máquina, mientras que uno de 8 bits deberá ejecutar varias instrucciones antes de tener el resultado, aun cuando ambos procesadores tengan la misma velocidad de ejecución para sus instrucciones. El procesador de 16 bits será más rápido porque puede hacer el mismo tipo de tareas que uno de 8 bits, en menos tiempo.
Unidad de control[editar]
Artículo principal: Unidad de control
Esta unidad es de las más importantes en el procesador, en ella recae la lógica necesaria para la decodificación y ejecución de las instrucciones, el control de los registros, la ALU, los buses y cuanta cosa más se quiera meter en el procesador.
La unidad de control es uno de los elementos fundamentales que determinan las prestaciones del procesador, ya que su tipo y estructura determina parámetros tales como el tipo de conjunto de instrucciones, velocidad de ejecución, tiempo del ciclo de máquina, tipo de buses que puede tener el sistema, manejo de interrupciones y un buen número de cosas más que en cualquier procesador van a parar a este bloque.
Por supuesto, las unidades de control son el elemento más complejo de un procesador y normalmente están divididas en unidades más pequeñas trabajando de conjunto. La unidad de control agrupa componentes tales como la unidad de decodificación, unidad de ejecución, controladores de memoria caché, controladores de buses, controlador de interrupciones, pipelines, entre otros elementos, dependiendo siempre del tipo de procesador.
Unidad aritmético-lógica (ALU)[editar]
Artículo principal: Unidad aritmética lógica
Como los procesadores son circuitos que hacen básicamente operaciones lógicas y matemáticas, se le dedica a este proceso una unidad completa, con cierta independencia. Aquí es donde se realizan las sumas, restas, y operaciones lógicas típicas del álgebra de Boole.
Actualmente este tipo de unidades ha evolucionado mucho y los procesadores más modernos tienen varias ALU, especializadas en la realización de operaciones complejas como las operaciones en coma flotante. De hecho en muchos casos le han cambiado su nombre por el de «coprocesador matemático», aunque este es un término que surgió para dar nombre a un tipo especial de procesador que se conecta directamente al procesador más tradicional.
Su impacto en las prestaciones del procesador es también importante porque, dependiendo de su potencia, tareas más o menos complejas, pueden hacerse en tiempos muy cortos, como por ejemplo, los cálculos en coma flotante.
Buses[editar]
Artículo principal: Bus (informática)
Son el medio de comunicación que utilizan los diferentes componentes del procesador para intercambiar información entre sí, eventualmente los buses o una parte de ellos estarán reflejados en los pines del encapsulado del procesador.
En el caso de los microcontroladores, no es común que los buses estén reflejados en el encapsulado del circuito, ya que estos se destinan básicamente a las E/S de propósito general y periféricos del sistema.
Existen tres tipos de buses:
Dirección: Se utiliza para seleccionar al dispositivo con el cual se quiere trabajar o en el caso de las memorias, seleccionar el dato que se desea leer o escribir.
Datos: Se utiliza para mover los datos entre los dispositivos de hardware (entrada y salida).
Control: Se utiliza para gestionar los distintos procesos de escritura lectura y controlar la operación de los dispositivos del sistema.
Conjunto de instrucciones[editar]
Artículo principal: Conjunto de instrucciones
Aunque no aparezca en el esquema, no podíamos dejar al conjunto o repertorio de instrucciones fuera de la explicación, porque este elemento determina lo que puede hacer el procesador.
Define las operaciones básicas que puede realizar el procesador, que conjugadas y organizadas forman lo que conocemos como software. El conjunto de instrucciones vienen siendo como las letras del alfabeto, el elemento básico del lenguaje, que organizadas adecuadamente permiten escribir palabras, oraciones y cuanto programa se le ocurra.
Existen dos tipos básicos de repertorios de instrucciones, que determinan la arquitectura del procesador: CISC y RISC.
CISC, del inglés Complex Instruction Set Computing, Computadora de conjunto de instrucciones complejo. Los microprocesadores CISC tienen un conjunto de instrucciones que se caracteriza por ser muy amplio y que permiten realizar operaciones complejas entre operandos situados en la memoria o en los registros internos. Este tipo de repertorio dificulta el paralelismo entre instrucciones, por lo que en la actualidad, la mayoría de los sistemas CISC de alto rendimiento convierten las instrucciones complejas en varias instrucciones simples del tipo RISC, llamadas generalmente microinstrucciones.
Dentro de los microcontroladores CISC podemos encontrar a la popular familia Intel 8051 y la Z80, aunque actualmente existen versiones CISC-RISC de estos microcontroladores, que pretenden aprovechar las ventajas de los procesadores RISC a la vez que se mantiene la compatibilidad hacia atrás con las instrucciones de tipo CISC.
RISC, del inglés Reduced Instruction Set Computer, Computadora con Conjunto de Instrucciones Reducido. Se centra en la obtención de procesadores con las siguientes características fundamentales:
Instrucciones de tamaño fijo.
Pocas instrucciones.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Número relativamente elevado de registros de propósito general.
Una de las características más destacables de este tipo de procesadores es que posibilitan el paralelismo en la ejecución, y reducen los accesos a memoria. Es por eso que los procesadores más modernos, tradicionalmente basados en arquitecturas CISC, implementan mecanismos de traducción de instrucciones CISC a RISC, para aprovechar las ventajas de este tipo de procesadores.
Los procesadores de los microcontroladores PIC son de tipo RISC.
Memoria[editar]
Artículo principal: Memoria (informática)
Anteriormente se ha visto que la memoria en los microcontroladores debe estar ubicada dentro del mismo encapsulado, esto es así la mayoría de las veces, porque la idea fundamental es mantener el grueso de los circuitos del sistema dentro de un solo integrado.
En los microcontroladores la memoria no es abundante, aquí no encontrará Gigabytes de memoria como en las computadoras personales. Típicamente la memoria de programas no excederá de 16 K-localizaciones de memoria no volátil (flash o eprom) para contener los programas.
La memoria RAM está destinada al almacenamiento de información temporal que será utilizada por el procesador para realizar cálculos u otro tipo de operaciones lógicas. En el espacio de direcciones de memoria RAM se ubican además los registros de trabajo del procesador y los de configuración y trabajo de los distintos periféricos del microcontrolador. Es por ello que en la mayoría de los casos, aunque se tenga un espacio de direcciones de un tamaño determinado, la cantidad de memoria RAM de que dispone el programador para almacenar sus datos es menor que la que puede direccionar el procesador.
El tipo de memoria utilizada en las memorias RAM de los microcontroladores es SRAM, lo que evita tener que implementar sistemas de refrescamiento como en el caso de las computadoras personales, que utilizan gran cantidad de memoria, típicamente alguna tecnología DRAM. A pesar de que la memoria SRAM es más costosa que la DRAM, es el tipo adecuado para los microcontroladores porque estos poseen pequeñas cantidades de memoria RAM.
En el caso de la memoria de programas se utilizan diferentes tecnologías, y el uso de una u otra depende de las características de la aplicación a desarrollar, a continuación se describen las cinco tecnologías existentes, que mayor utilización tienen o han tenido:
Máscara ROM. En este caso no se “graba” el programa en memoria sino que el microcontrolador se fabrica con el programa, es un proceso similar al de producción de los CD comerciales mediante masterización. El costo inicial de producir un circuito de este tipo es alto, porque el diseño y producción de la máscara es un proceso costoso, sin embargo, cuando se necesitan varios miles o incluso cientos de miles de microcontroladores para una aplicación determinada, como por ejemplo, algún electrodoméstico, el costo inicial de producción de la máscara y el de fabricación del circuito se distribuye entre todos los circuitos de la serie, y el costo final de esta es bastante menor que el de sus semejantes con otro tipo de memoria.
Memoria PROM (Programmable Read-Only Memory) también conocida como OTP (One Time Programmable). Este tipo de memoria también es conocida como PROM o simplemente ROM.
Los microcontroladores con memoria OTP se pueden programar una sola vez, con algún tipo de programador. Se utilizan en sistemas donde el programa no requiera futuras actualizaciones y para series relativamente pequeñas, donde la variante de máscara sea muy costosa, también para sistemas que requieren serialización de datos, almacenados como constantes en la memoria de programas.
Memoria EPROM (Erasable Programmable Read Only Memory). Los microcontroladores con este tipo de memoria son muy fáciles de identificar porque su encapsulado es de cerámica y llevan encima una ventanita de vidrio desde la cual puede verse la oblea de silicio del microcontrolador.
Se fabrican así porque la memoria EPROM es reprogramable, pero antes debe borrase, y para ello hay que exponerla a una fuente de luz ultravioleta, el proceso de grabación es similar al empleado para las memorias OTP.
Al aparecer tecnologías menos costosas y más flexibles, como las memorias EEPROM y FLASH, este tipo de memoria han caído en desuso, se utilizaban en sistemas que requieren actualizaciones del programa y para los procesos de desarrollo y puesta a punto.
EEPROM (Electrical Erasable Programmable Read Only Memory). Fueron el sustituto natural de las memorias EPROM, la diferencia fundamental es que pueden ser borradas eléctricamente, por lo que la ventanilla de cristal de cuarzo y los encapsulados cerámicos no son necesarios.
Al disminuir los costos de los encapsulados, los microcontroladores con este tipo de memoria se hicieron más baratos y cómodos para trabajar que sus equivalentes con memoria EPROM.
Otra característica destacable de este tipo de microcontrolador es que fue en ellos donde comenzaron a utilizarse los sistemas de programación en el sistema que evitan tener que sacar el microcontrolador de la tarjeta que lo aloja para hacer actualizaciones al programa.
Memoria flash. En el campo de las memorias reprogramables para microcontroladores, son el último avance tecnológico en uso a gran escala, y han sustituido a los microcontroladores con memoria EEPROM.
A las ventajas de las memorias flash se le adicionan su gran densidad respecto a sus predecesoras lo que permite incrementar la cantidad de memoria de programas a un costo muy bajo. Pueden además ser programadas con las mismas tensiones de alimentación del microcontrolador, el acceso en lectura y la velocidad de programación es superior, disminución de los costos de producción, entre otras.
Lo más habitual es encontrar que la memoria de programas y datos está ubicada toda dentro del microcontrolador, de hecho, actualmente son pocos los microcontroladores que permiten conectar memoria de programas en el exterior del encapsulado. Las razones para estas “limitaciones” están dadas porque el objetivo fundamental es obtener la mayor integración posible y conectar memorias externas consume líneas de E/S que son uno de los recursos más preciados de los microcontroladores.
A pesar de lo anterior existen familias como la Intel 8051 cuyos microcontroladores tienen la capacidad de ser expandidos en una variada gama de configuraciones para el uso de memoria de programas externa. En el caso de los PIC, estas posibilidades están limitadas solo a algunos microcontroladores de la gama alta, la Figura 5 muestra algunas de las configuraciones para memoria de programa que podemos encontrar en los microcontroladores. La configuración (a) es la típica y podemos encontrarla casi en el 100% de los microcontroladores. La configuración (b) es poco frecuente y generalmente se logra configurando al microcontrolador para sacrificar la memoria de programas interna, sin embargo el Intel 8031 es un microcontrolador sin memoria de programas interna. La configuración (c) es la que se encuentra habitualmente en los microcontroladores que tienen posibilidades de expandir su memoria de programas como algunos PIC de gama alta.
Cuando se requiere aumentar la cantidad de memoria de datos, lo más frecuente es colocar dispositivos de memoria externa en forma de periféricos, de esta forma se pueden utilizar memorias RAM, FLASH o incluso discos duros como los de los ordenadores personales, mientras que para los cálculos y demás operaciones que requieran almacenamiento temporal de datos se utiliza la memoria RAM interna del microcontrolador. Esta forma de expandir la memoria de datos está determinada, en la mayoría de los casos, por el tipo de repertorio de instrucciones del procesador y porque permite un elevado número de configuraciones distintas, además del consiguiente ahorro de líneas de E/S que se logra con el uso de memorias con buses de comunicación serie.
Interrupciones[editar]
Artículo principal: Interrupción
Las interrupciones son esencialmente llamadas a subrutina generadas por los dispositivos físicos, al contrario de las subrutinas normales de un programa en ejecución. Como el salto de subrutina no es parte del hilo o secuencia de ejecución programada, el controlador guarda el estado del procesador en la pila de memoria y entra a ejecutar un código especial llamado "manejador de interrupciones" que atiende al periférico específico que generó la interrupción. Al terminar la rutina, una instrucción especial le indica al procesador el fin de la atención de la interrupción. En ese momento el controlador restablece el estado anterior, y el programa que se estaba ejecutando antes de la interrupción sigue como si nada hubiese pasado. Las rutinas de atención de interrupciones deben ser lo más breves posibles para que el rendimiento del sistema sea satisfactorio, porque normalmente cuando una interrupción es atendida, todas las demás interrupciones están en espera.
Imagine que está esperando la visita de un amigo, al que llamaremos Juan. Usted y Juan han acordado que cuando él llegue a su casa esperará pacientemente a que le abra la puerta. Juan no debe tocar a la puerta porque alguien en la casa duerme y no quiere que le despierten.
Ahora usted ha decidido leer un libro mientras espera a que Juan llegue a la casa, y para comprobar si ha llegado, cada cierto tiempo detiene la lectura, marca la página donde se quedó, se levanta y va hasta la puerta, abre y comprueba si Juan ha llegado, si éste todavía no está en la puerta, esperará unos minutos, cerrará la puerta y regresará a su lectura durante algún tiempo.
Como verá este es un método poco eficiente para esperar a Juan porque requiere que deje la lectura cada cierto tiempo y vaya hasta la puerta a comprobar si él ha llegado, además debe esperar un rato si todavía no llega. Y por si fuera poco, imagine que Juan no llega nunca porque se le presentó un problema, tuvo que cancelar la cita y no pudo avisarle a tiempo, o peor, que Juan ha llegado a la puerta un instante después que usted la cerraba. Juan, respetando lo acordado, espera un tiempo, pero se cansa de esperar a que le abran y decide marcharse porque cree que ya usted no está en la casa o no puede atenderlo. A este método de atender la llegada de Juan lo llamaremos encuesta.
Veamos ahora otro método. En esta ocasión simplemente se recuesta en el sofá de la sala y comienza a leer su libro, cuando Juan llegue debe tocar el timbre de la puerta y esperar unos momentos a que le atiendan. Cuando usted oye sonar el timbre, interrumpe la lectura, marca la página donde se quedó y va hasta la puerta para atender a la persona que toca el timbre. Una vez que Juan o la persona que ha tocado el timbre, se marcha, usted regresa a su asiento y retoma la lectura justo donde la dejó. Este último es un método más eficiente que el anterior porque le deja más tiempo para leer y elimina algunos inconvenientes como el de que Juan nunca llegue o se marche antes de que usted abra la puerta. Es, en principio, un método simple pero muy eficaz y eficiente, lo llamaremos atención por interrupción.
El primero de ellos, la encuesta, es un método eficaz, pero poco eficiente porque requiere realizar lecturas constantes y muchas veces innecesarias del estado del proceso que queremos atender. Sin embargo, es muy utilizado en la programación de microcontroladores porque resulta fácil de aprender, la implementación de código con este método es menos compleja y no requiere de hardware especial para llevarla adelante. Por otra parte, la encuesta, tiene muchas deficiencias que con frecuencia obligan al diseñador a moverse hacia otros horizontes
El mundo está lleno de situaciones; de las cuales no podemos determinar ni cuando, ni como ni por qué se producen, en la mayoría de los casos lo único que podemos hacer es enterarnos de que determinada situación, asociada a un proceso, ha ocurrido. Para ello seleccionamos alguna condición o grupo de condiciones que nos indican que el proceso que nos interesa debe ser atendido, a este fenómeno, en el cual se dan las condiciones que nos interesa conocer, lo llamaremos evento. En el segundo ejemplo vemos que para atender a Juan, este debe tocar el timbre, por tanto, la llegada de Juan es el proceso que debemos atender y el sonido del timbre es el evento que nos indica que Juan ha llegado.
El método de atención a procesos por interrupción, visto desde la óptica del ejemplo que utilicé para mostrarlo, es más simple que el de la encuesta, pero no es cierto, el método se complica porque requiere que el microprocesador incorpore circuitos adicionales para registrar los eventos que le indican que debe atender al proceso asociado y comprender estos circuitos y su dinámica no es una tarea sencilla.
Los circuitos para la atención a las interrupciones y todas las tareas que debe realizar el procesador para atender al proceso que lo interrumpe son bastante complejos y requieren una visión diferente de la que estamos acostumbrados a tener de nuestro mundo.
Los seres humanos no estamos conscientes de las interrupciones, en nuestro organismo existen mecanismos que nos interrumpen constantemente, para ello tenemos a nuestro sistema sensorial, pero no somos conscientes del proceso de interrupción, aunque sí de la atención a las interrupciones. Eso es porque incorporamos mecanismos que nos sacan rápidamente de la tarea que estemos haciendo para atender una situación que no puede o no debe esperar mucho tiempo. Bien, esa misma es la idea que se incorpora en los microprocesadores para atender procesos que no pueden esperar o que no sabemos cuando deben ser atendidos porque ello depende de determinadas condiciones.
La cosa se complica en la secuencia de acciones a realizar desde el momento en que se desencadena el proceso de interrupción, hasta que se ejecuta el programa que lo atiende, y en la secuencia de acciones posteriores a la atención. Piense en cuantas cosas debe hacer su organismo ante una interrupción, utilicemos el segundo ejemplo para atender la llegada de Juan. Piense en cuantas cosas su cerebro hace a espaldas de su conciencia, desde el momento en que suena el timbre hasta que usted se encuentra listo (consciente de que es probable que Juan ha llegado) para abrir la puerta, y todo lo que su cerebro debe trabajar para retomar la lectura después que Juan se ha marchado. Todo eso, excepto abrir la puerta y atender a Juan, lo hacemos de forma “inconsciente” porque para ello tenemos sistemas dedicados en nuestro organismo, pero en el mundo de los microcontroladores debemos conocer todos esos detalles para poder utilizar los mecanismos de interrupción.
Los procesos de atención a interrupciones tienen la ventaja de que se implementan por hardware ubicado en el procesador, así que es un método rápido de hacer que el procesador se dedique a ejecutar un programa especial para atender eventos que no pueden esperar por mecanismos lentos como el de encuesta.
En términos generales, un proceso de interrupción y su atención por parte del procesador, tiene la siguiente secuencia de acciones:
En el mundo real se produce el evento para el cual queremos que el procesador ejecute un programa especial, este proceso tiene la característica de que no puede esperar mucho tiempo antes de ser atendido o no sabemos en que momento debe ser atendido.
El circuito encargado de detectar la ocurrencia del evento se activa, y como consecuencia, activa la entrada de interrupción del procesador.
La unidad de control detecta que se ha producido una interrupción y “levanta” una bandera para registrar esta situación; de esta forma si las condiciones que provocaron el evento desaparecen y el circuito encargado de detectarlo desactiva la entrada de interrupción del procesador, esta se producirá de cualquier modo, porque ha sido registrada.
La unidad de ejecución termina con la instrucción en curso y justo antes de comenzar a ejecutar la siguiente comprueba que se ha registrado una interrupción
Se desencadena un proceso que permite guardar el estado actual del programa en ejecución y saltar a una dirección especial de memoria de programas, donde está la primera instrucción de la subrutina de atención a interrupción.
Se ejecuta el código de atención a interrupción, esta es la parte “consciente” de todo el proceso porque es donde se realizan las acciones propias de la atención a la interrupción y el programador juega su papel.
Cuando en la subrutina de atención a interrupción se ejecuta la instrucción de retorno, se desencadena el proceso de restauración del procesador al estado en que estaba antes de la atención a la interrupción.
Como podemos observar, el mecanismo de interrupción es bastante complicado, sin embargo tiene dos ventajas que obligan a su implementación: la velocidad y su capacidad de ser asíncrono. Ambas de conjunto permiten que aprovechemos al máximo las capacidades de trabajo de nuestro procesador.
Los mecanismos de interrupción no solo se utilizan para atender eventos ligados a procesos que requieren atención inmediata sino que se utilizan además para atender eventos de procesos asíncronos.
Las interrupciones son tan eficaces que permiten que el procesador actúe como si estuviese haciendo varias cosas a la vez cuando en realidad se dedica a la misma rutina de siempre, ejecutar instrucciones una detrás de la otra.
Periféricos[editar]
Artículo principal: Periférico (informática)
Cuando observamos la organización básica de un microcontrolador, señalamos que dentro de este se ubican un conjunto de periféricos. A continuación describiremos algunos de los periféricos que con mayor frecuencia encontraremos en los microcontroladores.
Entradas y salidas de propósito general[editar]
También conocidos como puertos de E/S, generalmente agrupadas en puertos de 8 bits de longitud, permiten leer datos del exterior o escribir en ellos desde el interior del microcontrolador, el destino habitual es el trabajo con dispositivos simples como relés, LED, o cualquier otra cosa que se le ocurra al programador.
Algunos puertos de E/S tienen características especiales que le permiten manejar salidas con determinados requerimientos de corriente, o incorporan mecanismos especiales de interrupción para el procesador.
Típicamente cualquier pin de E/S puede ser considerada E/S de propósito general, pero como los microcontroladores no pueden tener infinitos pines, ni siquiera todos los pines que queramos, las E/S de propósito general comparten los pines con otros periféricos. Para usar un pin con cualquiera de las características a él asignadas debemos configurarlo mediante los registros destinados a ellos.
Temporizadores y contadores[editar]
Son circuitos sincrónicos para el conteo de los pulsos que llegan a su poder para conseguir la entrada de reloj. Si la fuente de un gran conteo es el oscilador interno del microcontrolador es común que no tengan un pin asociado, y en este caso trabajan como temporizadores. Por otra parte, cuando la fuente de conteo es externa, entonces tienen asociado un pin configurado como entrada, este es el modo contador.
Los temporizadores son uno de los periféricos más habituales en los microcontroladores y se utilizan para muchas tareas, como por ejemplo, la medición de frecuencia, implementación de relojes, para el trabajo de conjunto con otros periféricos que requieren una base estable de tiempo entre otras funcionalidades. Es frecuente que un microcontrolador típico incorpore más de un temporizador/contador e incluso algunos tienen arreglos de contadores. Como veremos más adelante este periférico es un elemento casi imprescindible y es habitual que tengan asociada alguna interrupción. Los tamaños típicos de los registros de conteo son 8 y 16 bits, pudiendo encontrar dispositivos que solo tienen temporizadores de un tamaño o con más frecuencia con ambos tipos de registro de conteo.
Conversor analógico/digital[editar]
Como es muy frecuente el trabajo con señales analógicas, estas deben ser convertidas a digital y por ello muchos microcontroladores incorporan un conversor analógico-digital, el cual se utiliza para tomar datos de varias entradas diferentes que se seleccionan mediante un multiplexor.
Las resoluciones más frecuentes son 8 y 10 bits, que son suficientes para aplicaciones sencillas. Para aplicaciones en control e instrumentación están disponibles resoluciones de 12bit, 16bit y 24bit.6 También es posible conectar un convertidor externo, en caso de necesidad
Puertos de comunicación[editar]
Puerto serie[editar]
Este periférico está presente en casi cualquier microcontrolador, normalmente en forma de UART (Universal Asynchronous Receiver Transmitter) o USART (Universal Synchronous Asynchronous Receiver Transmitter) dependiendo de si permiten o no el modo sincrónico de comunicación.
El destino común de este periférico es la comunicación con otro microcontrolador o con una PC y en la mayoría de los casos hay que agregar circuitos externos para completar la interfaz de comunicación. La forma más común de completar el puerto serie es para comunicarlo con una PC mediante la interfaz EIA-232 (más conocida como RS-232), es por ello que muchas personas se refieren a la UART o USART como puerto serie RS-232, pero esto constituye un error, puesto que este periférico se puede utilizar para interconectar dispositivos mediante otros estándares de comunicación. En aplicaciones industriales se utiliza preferiblemente RS-485 por sus superior alcance en distancia, velocidad y resistencia al ruido.
SPI[editar]
Este tipo de periférico se utiliza para comunicar al microcontrolador con otros microcontroladores o con periféricos externos conectados a él, por medio de una interfaz muy sencilla. Hay solo un nodo controlador que permite iniciar cualquier transacción, lo cual es una desventaja en sistemas complejos, pero su sencillez permite el aislamiento galvánico de forma directa por medio de optoacopladores.
I2C[editar]
Cumple las mismas funciones que el SPI, pero requiere menos señales de comunicación y cualquier nodo puede iniciar una transacción. Es muy utilizado para conectar las tarjetas gráficas de las computadoras personales con los monitores, para que estos últimos informen de sus prestaciones y permitir la autoconfiguración del sistema de vídeo.
USB[editar]
Los microcontroladores son los que han permitido la existencia de este sistema de comunicación. Es un sistema que trabaja por polling (monitorización) de un conjunto de periféricos inteligentes por parte de un amo, que es normalmente un computador personal. Cada modo inteligente está gobernado inevitablemente por un microcontrolador.
Ethernet[editar]
Artículo principal: Ethernet
Es el sistema más extendido en el mundo para redes de área local cableadas. Los microcontroladores más poderosos de 32 bits se usan para implementar periféricos lo suficientemente poderosos como para que puedan ser accedidos directamente por la red. Muchos de los enrutadores caseros de pequeñas empresas están construidos sobre la base de un microcontrolador que hace del cerebro del sistema.
Can[editar]
Este protocolo es del tipo CSMA/CD con tolerancia a elevados niveles de tensión de modo común y orientado al tiempo real. Este protocolo es el estándar más importante en la industria automotriz (OBD). También se usa como capa física del "field bus" para el control industrial.
Otros puertos de comunicación[editar]
Hay una enorme cantidad de otros buses disponibles para la industria automotriz (linbus) o de medios audiovisuales como el i2s, IEEE 1394. El usuario se los encontrará cuando trabaje en algún área especializada.
Comparadores[editar]
Son circuitos analógicos basados en amplificadores operacionales que tienen la característica de comparar dos señales analógicas y dar como salida los niveles lógicos ‘0’ o ‘1’ en dependencia del resultado de la comparación. Es un periférico muy útil para detectar cambios en señales de entrada de las que solamente nos interesa conocer cuando está en un rango determinado de tensión.
Modulador de ancho de pulsos[editar]
Los PWM (Pulse Width Modulator) son periféricos muy útiles sobre todo para el control de motores, sin embargo hay un grupo de aplicaciones que pueden realizarse con este periférico, dentro de las cuales podemos citar: inversión DC/AC para UPS, conversión digital analógica D/A, control regulado de luz (dimming) entre otras.
Memoria de datos no volátil[editar]
Muchos microcontroladores han incorporado estos tipos de memoria como un periférico más, para el almacenamiento de datos de configuración o de los procesos que se controlan. Esta memoria es independiente de la memoria de datos tipo RAM o la memoria de programas, en la que se almacena el código del programa a ejecutar por el procesador del microcontrolador.
Muchos de los microcontroladores PIC incluyen este tipo de memoria, típicamente en forma de memoria EEPROM, incluso algunos de ellos permiten utilizar parte de la memoria de programas como memoria de datos no volátil, por lo que el procesador tiene la capacidad de escribir en la memoria de programas como si esta fuese un periférico más.
Familias de microcontroladores[editar]
Véase también: Anexo:Microcontroladores comunes
Los microcontroladores más comunes en uso son:
Empresa	8 bits	16 bits	32 bits
Atmel
AVR (mega y tiny), 89Sxxxx familia similar 8051
	SAM7 (ARM7TDMI), SAM3 (ARM Cortex-M3), SAM9 (ARM926), AVR32

Freescale
(antes Motorola)
68HC05, 68HC08, 68HC11, HCS08
68HC12, 68HCS12, 68HCSX12, 68HC16
683xx, PowerPC, ColdFire

Holtek
HT8
	
Intel
MCS-48 (familia 8048)
MCS51 (familia 8051)
8xC251
MCS96, MXS296
x
National Semiconductor
COP8
x	x
Microchip
Familia 10f2xx Familia 12Cxx Familia 12Fxx, 16Cxx y 16Fxx 18Cxx y 18Fxx	PIC24F, PIC24H y dsPIC30FXX, dsPIC33F con motor dsp integrado	PIC32
NXP Semiconductors
(antes Philips)
80C51	XA	Cortex-M3, Cortex-M0, ARM7, ARM9
Renesas
(antes Hitachi, Mitsubishi y NEC)	78K, H8
H8S, 78K0R, R8C, R32C/M32C/M16C
RX, V850, SuperH, SH-Mobile, H8SX

STMicroelectronics
ST 62, ST 7
	STM32 (ARM7)

Texas Instruments
TMS370
MSP430
C2000, Cortex-M3 (ARM), TMS570 (ARM)
Zilog
Z8, Z86E02
	
Observación: Algunas arquitecturas de microcontrolador están disponibles por tal cantidad de vendedores y en tantas variedades, que podrían tener, con total corrección, su propia categoría. Entre ellos encontramos, principalmente, las variantes de Intel 8051 y Z80.
Véase también[editar]
Lista de microcontroladores comunes
Controladora de periférico
Microprocesador
Microbótica
PIC16F87X
Intel HEX
Informática de sistemas
Ingeniería Técnica en Informática de Gestión
BASIC Stamp
Arduino
Referencias[editar]
↑ Vienna University of Technology, Introduction To Microcontrollers (Gunther Gridling, Bettina Weiss), 26 de febrero de 2007
↑ Augarten, Stan (1983). The Most Widely Used Computer on a Chip: The TMS 1000. State of the Art: A Photographic History of the Integrated Circuit. New Haven y New York: Ticknor & Fields. ISBN 0-89919-195-9. Consultado el 2 de marzo de 2012.
↑ Saltar a:a b https://web.archive.org/web/20120619154428/http://archive.computerhistory.org/resources/access/text/Oral_History/102658328.05.01.acc.pdf Oral History Panel on the Development and Promotion of the Intel 8048 Microcontroller, Computer History Museum oral history, 2008, consultado el 28 de junio de 2011, página 4
↑ http://microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2018&mcparam=en013082
↑ "Atmel’s Self-Programming Flash Microcontrollers" de Odd Jostein Svendsli 2003
↑ microcontroladores "analógicos"
 
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema de computadoras.1Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede a las direcciones de memoria.
También la arquitectura del computador está basado en tres grandes principios que se aplican a todo dispositivo o componente del computador, estos tres principios son: velocidad, capacidad y tipo de conexión.
También suele definirse como la forma de interconectar componentes de hardware, para crear computadoras según los requerimientos de funcionalidad, rendimiento y costo.
La computadora recibe y envía la información a través de los periféricos, por medio de los canales. La CPU es la encargada de procesar la información que le llega a la computadora. El intercambio de información se tiene que hacer con los periféricos y la CPU. Puede considerarse que todas aquellas unidades de un sistema, exceptuando la CPU, se denomina periférico, por lo que la computadora tiene dos partes bien definidas, que son:
La CPU (encargada de ejecutar programas y que también se considera compuesta por la memoria principal, la unidad aritmético lógica y la unidad de control).
Los periféricos (que pueden ser de entrada, salida, entrada/salida, almacenamiento y comunicaciones).
 
Índice
1Introducción
2Puertas lógicas
3Almacenamiento de operandos en la CPU
3.1Ventajas de las arquitecturas
3.2Desventajas de las arquitecturas
4Notas
5Véase también
6Enlaces externos
Introducción[editar]
La implantación de instrucciones es similar al uso de una serie de montaje en una fábrica de manufacturación. En las cadenas de montaje, el producto pasa a través de muchas etapas de producción antes de tener el producto armado. Cada etapa o segmento de la cadena está especializada en un área específica de la línea de producción y lleva a cabo siempre la misma actividad. Esta tecnología es aplicada en el diseño de procesadores eficientes.
A estos procesadores se les conoce como pipeline processors. Estos están compuestos por una lista de segmentos lineales y secuenciales en donde cada segmento lleva a cabo una tarea o un grupo de tareas computacionales. Los datos que provienen del exterior se introducen en el sistema para ser procesados. La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información para el uso externo.
Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes aspectos:
Almacenamiento de operandos en la CPU: dónde se ubican los operadores aparte de la substractora informativa (SI).
Cantidad de operandos explícitos por instrucción: cuántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.
Posición del operando: ¿cualquier operando puede estar en memoria, o deben estar algunos o todos en los registros internos de la CPU?. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).
Operaciones: qué operaciones están disponibles en el conjunto de instrucciones.
Tipo y tamaño de operandos y cómo se especifican.
Puertas lógicas[editar]
Son las encargadas de procesar la lógica de las instrucciones del sistema. Existen siete tipos básicos diferentes:
NOT: es la negación de la entrada. Funciona con una sola entrada y una sola salida.
AND: es la multiplicación binaria de dos entradas y da una sola salida.
OR: es la suma binaria de dos entradas y da como salida la suma propia o el bit carry de ser necesario.
XOR: es la suma binaria de dos entradas y da el resultado como salida, sin incluir el bit carry.
NAND: es la negación de AND. Da una única salida.
NOR: es la negación de OR. Da una única salida.
XNOR: es la negación de XOR. Da una única salida.
Almacenamiento de operandos en la CPU[editar]
La diferencia básica está en el almacenamiento interno de la CPU. Las principales alternativas son:
Acumulador.
Conjunto de registros.
Memoria.
Pero antes hay que tomar en cuenta que las informaciones procesadas son de suma importancia.
Características
En una arquitectura de acumulador, un operando está implícitamente en el acumulador siempre leyendo e ingresando datos (por ejemplo, una calculadora estándar).
En la arquitectura de una pila no es necesario nombrar a los operandos ya que estos se encuentran en el tope de la pila (por ejemplo, calculadora de pila HP).
La arquitectura de registros tiene sólo operandos explícitos (es aquel que se nombra) en registros o memoria.
Ventajas de las arquitecturas[editar]
Pila:
Modelo sencillo para evaluación de expresiones (notación polaca inversa).
Instrucciones cortas pueden dar una buena densidad de código.
Acumulador:
Instrucciones cortas.
Minimiza estados internos de la máquina (unidad de control sencilla).
Registro:
Modelo más general para el código de instrucciones parecidas.
Automatiza generación de código y la reutilización de operandos.
Reduce el tráfico a memoria.
Una computadora tiene 32 registros, como estándar.
El acceso a los datos es más rápido y veloz.
Desventajas de las arquitecturas[editar]
Pila:
A una pila no se puede acceder aleatoriamente.
Esta limitación hace difícil generar código eficiente.
También dificulta una implementación eficiente, ya que la pila llega a ser un cuello de botella es decir que existe dificultad para la transferencia de datos en su velocidad mk.
Acumulador:
Como el acumulador es solamente almacenamiento temporal, el tráfico de memoria es el más alto en esta aproximación.
Registro:
Todos los operadores deben ser nombrados, conduciendo a instrucciones más largas.
Notas[editar]
↑ Montaje de componentes y periféricos microinformáticos. IFCT0108, en Google libros
Véase también[editar]
32 bits
64 bits
Arquitectura de CPU
Arquitectura de von Neumann
Arquitectura Harvard
Computadora
Mantenimiento preventivo
Enlaces externos[editar]
Arquitectura de computadores
Universidad Politécnica de Cataluña, Departamento de Arquitectura de computadores
Arquitectura de von Neumann
Arquitectura de 32 o 64 bits en Windows
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
1El lenguaje máquina
2Implementación del conjunto de instrucciones
3Diseño
3.1Densidad del código
3.2Número de operando
3.3Características deseables
4Tipos de instrucciones y ejemplos
4.1Transferencia de datos
4.2Instrucciones aritméticas
4.3Instrucciones de comparación
4.4Instrucciones lógicas
4.5Instrucciones de desplazamiento
4.6Instrucciones de bits
4.7Instrucciones de control
4.7.1Saltos
4.7.2Llamadas a subrutinas
4.7.3Gestión de interrupciones
4.8Instrucciones de entrada y salida
4.9Instrucciones de control y misceláneas
5Véase también
6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
Registros particulares para operaciones aritméticas, de direccionamiento o de control.
Ubicaciones particulares de la memoria.
Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
Desplazamiento.
Establecer un registro a un valor constante.
Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
Leer y escribir datos desde dispositivos de hardware.
Operaciones matemáticas.
Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
Afectan al flujo de programa.
Saltar a otra posición del programa y ejecutar instrucciones allí.
Saltar a otra posición si se cumple cierta condición.
Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
Ahorro de registros en la pila.
Mover grandes bloques de memoria.
Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
Un conjunto de instrucciones, repertorio de instrucciones, juego de instrucciones o ISA (del inglés instruction set architecture, «arquitectura del conjunto de instrucciones») es una especificación que detalla las instrucciones que una unidad central de procesamiento puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU. El término describe los aspectos del procesador generalmente visibles para un programador, incluidos los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
Existen principalmente tres tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Simple Instruction Set Computing).
La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentran las microinstrucciones y los sistemas de caché.
Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo, el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños diferentes.
 
Índice
•	1El lenguaje máquina
•	2Implementación del conjunto de instrucciones
•	3Diseño
o	3.1Densidad del código
o	3.2Número de operando
o	3.3Características deseables
•	4Tipos de instrucciones y ejemplos
o	4.1Transferencia de datos
o	4.2Instrucciones aritméticas
o	4.3Instrucciones de comparación
o	4.4Instrucciones lógicas
o	4.5Instrucciones de desplazamiento
o	4.6Instrucciones de bits
o	4.7Instrucciones de control
	4.7.1Saltos
	4.7.2Llamadas a subrutinas
	4.7.3Gestión de interrupciones
o	4.8Instrucciones de entrada y salida
o	4.9Instrucciones de control y misceláneas
•	5Véase también
•	6Referencias
El lenguaje máquina[editar]
El lenguaje máquina está construido a partir de los estados discretos o instrucciones. En la arquitectura de procesamiento, una instrucción dada puede especificar muy bien:
•	Registros particulares para operaciones aritméticas, de direccionamiento o de control.
•	Ubicaciones particulares de la memoria.
•	Modos de direccionamiento para interpretar a los operandos. ej.:
"si quieres que el robot cambie un foco quemado súbete a la escalera, alcanza el foco, quita el foco quemado, pon el foco nuevo, baja de la escalera, quita la escalera."
Las operaciones más complejas se construyen a partir de estas, que (en una máquina Von Neumann) se ejecutan secuencialmente, o según el control de flujo.
Muchas o pocas de las operaciones disponibles incluidas en la mayoría de conjuntos son:
•	Desplazamiento.
o	Establecer un registro a un valor constante.
o	Mover datos desde una posición de memoria a un registro y viceversa. Esto se realiza para obtener datos para operaciones matemáticas y su almacenamiento.
o	Leer y escribir datos desde dispositivos de hardware.
•	Operaciones matemáticas.
o	Sumar, restar, multiplicar o dividir dos registros y colocar el resultado en alguno de ellos.
o	Realizar operaciones bit a bit, teniendo el AND y el OR de cada bit en un par de registros, o el NOT de cada bit en un registro.
o	Comparar dos valores que se encuentren en registros (por ejemplo, si son iguales o si uno es mayor que otro).
•	Afectan al flujo de programa.
o	Saltar a otra posición del programa y ejecutar instrucciones allí.
o	Saltar a otra posición si se cumple cierta condición.
o	Saltar a otra posición, pero salvando la posición actual para poder volver (realizar una llamada, por ejemplo call printf).
Algunas computadoras incluyen instrucciones "complejas". Dichas instrucciones pueden tomar muchas instrucciones en otros equipos. Estas se caracterizan por instrucciones que necesitan varios pasos, como el control de múltiples unidades funcionales.
Algunos ejemplos son:
•	Ahorro de registros en la pila.
•	Mover grandes bloques de memoria.
•	Complejas operaciones and/or con aritmética de coma flotante, tales como el seno o la raíz cuadrada.
•	Instrucciones que combinan ALU con un operando de la memoria más que de registros.
Un tipo complejo de la instrucción que ha llegado a ser particularmente popular recientemente es SIMD (Single Instruction, Multiple Data), una operación que realice la misma operación aritmética en pedazos múltiples de datos al mismo tiempo. SIMD tienen la capacidad de manipular vectores y matrices grandes en tiempo mínimo. Las instrucciones de SIMD permiten la paralelización fácil de los algoritmos implicados comúnmente en sonido, imagen, y el proceso video. Varias implementaciones de SIMD se han traído al mercado bajo nombres comerciales tales como MMX, 3DNow! y AltiVec.
Diseñar sistemas de instrucciones es muy complejo. En un principio existieron dos tipos de sistemas, un modo de clasificarlos es por complejidad arquitectónica. El primer tipo era el CISC (Complex Instruction Set Computer) que tenía muchas instrucciones diferentes. En los años 1970, IBM hicieron una investigación en la que encontraron que muchas instrucciones en el sistema podrían ser eliminadas. El resultado fue el segundo tipo, el RISC (Reduced Instruction Set Computer), una arquitectura que utiliza un sistema más pequeño de instrucciones. Un conjunto de instrucción más simple puede ofrecer el potencial para velocidades más altas, tamaño reducido del procesador, y un consumo de energía reducido. Sin embargo, un conjunto más complejo puede optimizar operaciones comunes, mejorar memoria/eficiencia de caché, o simplificar la programación.
Implementación del conjunto de instrucciones[editar]
Cualquier conjunto de instrucciones se puede implementar de varias maneras. Todas las maneras de implementar un conjunto de instrucciones dan el mismo modelo programado, y todas pueden hacer funcionar los mismos ejecutables binarios. Las varias maneras de implementar un conjunto de instrucciones dan diversas compensaciones entre el coste, el funcionamiento, el consumo de energía, el tamaño, etc.
Al diseñar microarquitecturas, los ingenieros usaron bloques de circuitos electrónicos “duramente-conectados” (diseñado a menudo por separado) por ejemplo, los multiplexores, los contadores, los registros, las ALU, etcétera. Un cierto tipo del lenguaje de transferencia de registros es a menudo usado para describir la codificación y la secuencia de cada instrucción de ISA usando esta microarquitectura física.
Hay también algunos nuevos diseños de CPU que compilan el conjunto de instrucción a una RAM escribible o FLASH dentro de la CPU (tal como el procesador Recursiv y el Imsys Cjip), o FPGA (computación reconfigurable). Western Digital MCP-1600 es un ejemplo antiguo, usando una ROM dedicada, separada del microcódigo.
ISA se puede también emular en software por un intérprete. Naturalmente, debido a la interpretación de “overhead”, es más lento que ejecutar programas directamente sobre el hardware emulado. Hoy, es práctica para los vendedores de nuevos ISA o microarquitecturas poner emuladores del software a disposición de los desarrolladores de programas informáticos antes de que la implementación del hardware esté lista.
Los detalles de la implementación tienen una influencia fuerte en las instrucciones particulares seleccionadas para el conjunto de instrucción. Por ejemplo, muchas implementaciones de la instrucción “pipline” permiten solamente una carga de memoria (load) o almacén en memoria (store) por instrucción, llevando a carga-almacena arquitectura (RISC). Por otro ejemplo, algunas maneras de implementar la instrucción “pipline” llevaron a una ranura de retardo.
La demanda de procesamiento de señal digital de alta velocidad ha empujado en el sentido contrario, forzando la implementación de instrucción de manera particular. Por ejemplo, para realizar los filtros digitales es bastante insuficiente, la instrucción del MAC en un procesador típico de señal digital (DSP) se debe implementar usando una arquitectura de Harvard que pueda traer una instrucción y dos palabras de datos simultáneamente, y requiere un solo ciclo.
Diseño[editar]
Densidad del código[editar]
En computadoras antiguas, la memoria del programa era costosa, así que minimizar el tamaño de un programa para asegurar que va a caber en la memoria limitada era a menudo central. Así el tamaño combinado de todas las instrucciones necesitó realizar una tarea particular, la densidad del código, era una característica importante de cualquier sistema de instrucción. Las computadoras con alta densidad del código también tenían a menudo instrucciones complejas para la entrada del procedimiento, los retornos parametrizados, los lazos, etc. Sin embargo, "instrucciones CISC" combinan simplemente una operación básica de la ALU, tal como "add", con el acceso de uno o más operandos en memoria (usando modos de dirección tales como directo, indirecto, indexado). Ciertas arquitecturas pueden permitir dos o tres operandos (incluido el resultado) directamente en memoria o pueden permitir realizar funciones tales como el incremento automático del puntero.
RISC, fueron los primeros implementados con profundidad en el período de rápido crecimiento de las memorias de subsistemas, se reduce el código con el fin de simplificar el circuito de aplicación y con ello tratar de aumentar el rendimiento a través de las frecuencias de reloj más elevadas y el uso de más registros. Las instrucciones RISC suelen realizar sólo una operación, como una "suma" de registros o una "carga" de una posición de memoria en un registro, también suelen utilizar una longitud de instrucciones fijas, mientras que un conjunto de instrucciones típicas CISC tiene instrucciones muchos más cortas que esta longitud fija. Las instrucciones de longitud fija son menos complicadas de manejar que las instrucciones de ancho variable, por varias razones (por ejemplo: no tener que comprobar si una instrucción se extiende a ambos lados de una línea de caché o el límite de memoria virtual de la página), y por lo tanto algo más fácil de optimizar la velocidad. Sin embargo, como los equipos RISC normalmente requieren más y más para implementar las instrucciones que ejecutan una determinada tarea, hacen menos óptimo el uso del ancho de banda y de la memoria caché.
Las computadoras mínimas del conjunto de instrucciones (MISC) son una forma de máquina apilada, donde hay pocas instrucciones separadas (16-64), para poder caber instrucciones múltiples en una sola palabra de máquina. Estos tipos de núcleos llevan a menudo poco silicio para implementarse, así que pueden ser observadas fácilmente en un FPGA o en una forma multinúcleo. La densidad del código es similar al RISC; la densidad creciente de la instrucción es compensada requiriendo más de las instrucciones primitivas para hacer una tarea.
Número de operando[editar]
El conjunto de instrucciones puede ser clasificado por el número máximo de operandos explícitamente especificados en las instrucciones (en los ejemplos que siguen, a, b y c se refieren a celdas de memoria, mientras que reg1 y sucesivos se refieren a los registros de la máquina).
0-operando, también llamada máquina de pila: todas las operaciones aritméticas se ejecutan en la parte superior de una o dos posiciones de la pila, push y pop son las instrucciones utilizadas para acceder a la memoria: push a, push b, add, pop c.
1-operando (máquinas de una dirección), también llamadas máquinas de acumulador, incluida en la mayoría de las primeras computadoras y muchos microcontroladores pequeños: la mayoría de instrucciones especifican un operando explícito a la derecha (un registro, una posición de memoria, o una constante) y un operando a la izquierda: load a, add b, store c.
2-operando, la mayoría de las máquinas CISC y RISC entran en esta categoría:
CISC – load a, reg1, add reg1, b; store reg1, c
RISC – cargas que requieren la memoria explícita, las instrucciones serían: load a,reg1; load b,reg2; add reg1,reg2; store reg2,c
3-operando, permite una mejor reutilización de los datos: CISC - bien una sola instrucción: add a, b, c, o más generalmente: move a,reg1; add reg1,b,c como la mayoría de las máquinas se limitan a dos operandos de memoria. RISC - Debido a la gran cantidad de bits necesarios para codificar los tres registros, este esquema no suele estar disponible en los procesadores RISC con pequeñas instrucciones de 16 bits: load a,reg1; load b,reg2; add reg1+reg2->reg3; store reg3,c.
Más operandos, algunas máquinas CISC permiten una variedad de modos de direccionamiento que permiten más de 3 operandos (registros o accesos a memoria), como el VAX "POLY", instrucción de evaluación de polinomio.
Características deseables[editar]
Las características que se pretende que tenga un conjunto de instrucciones son cuatro, principalmente:
•	Completo: que se pueda realizar en un tiempo finito cualquier tarea ejecutable con un ordenador (computable o decidible).
•	Eficiente: que permita alta velocidad de cálculo sin exigir una elevada complejidad en su UC y ALU y sin consumir excesivos recursos (memoria), es decir, debe cumplir su tarea en un tiempo razonable minimizando el uso de los recursos.
•	Autocontenidas: esto es, que contengan en sí mismas toda la información necesaria para ejecutarse.
•	Independientes: que no dependan de la ejecución de alguna otra instrucción.
Se puede comprobar que para que un conjunto de instrucciones sea completo solo se necesitan cuatro instrucciones:
•	Escritura.
•	Mover a la izquierda una posición y leer.
•	Mover a la derecha una posición y leer.
•	Parar.
En esta idea se basan las arquitecturas RISC, no obstante, con este conjunto no se puede conseguir la eficiencia del repertorio de instrucciones por lo que en la práctica el conjunto suele ser más amplio en aras de conseguir un mejor rendimiento, tanto en uso de recursos como en consumo de tiempo.
Tipos de instrucciones y ejemplos[editar]
Transferencia de datos[editar]
Copian datos de un origen a un destino, sin modificar el origen y normalmente sin afectar a los flags o indicadores de condición. Pueden transferir palabras, fracciones de palabras (bytes, media palabra) o bloques completos de n bytes o palabras.
Estas operaciones pueden ser:
•	registro a registro.
•	registro a memoria.
•	memoria a registro.
•	memoria a memoria.
Nemotécnicos más frecuentes
•	move copia el contenido de un registro (o memoria) a otro.
•	store copia el contenido de un registro a memoria.
•	load copia el contenido de una posición de memoria a un registro.
•	move block copia un bloque de datos de una posición de memoria a otra.
•	move multiple copia del origen en varias posiciones de memoria.
•	exchange intercambia el contenido de dos operandos.
•	clear pone a 0 el destinto (todos los bits).
•	set pone a 1 el destino (todos los bits).
•	push introduce un dato en la cabecera de la pila (indicada por el SP).
•	pop saca un dato de la cabecera de la pila (indicada por el SP).
Instrucciones aritméticas[editar]
Son efectuadas por la ALU y suelen cambiar los flags o indicadores de condición.
Nemotécnicos más frecuentes
•	add: suma.
•	add with carry: suma con acarreo.
•	subtract: resta.
•	subtract with borrow: resta teniendo en cuenta el adeudo anterior.
•	increment: incrementa en 1 un valor.
•	decrement: decrementa en 1 un valor.
•	multiply: multiplica.
•	divide: divide.
•	extend: aumenta el operando de tamaño.
•	negate: cambia de signo.
•	absolute: valor absoluto.
Pueden tener instrucciones para tratar con números en BCD e incluyen operaciones en coma flotante, lo cual se identifica con una 'f' antes del nombre del nemotécnico como por ejemplo: fabsolute
Instrucciones de comparación[editar]
Suelen preceder a una instrucción de bifurcación condicional y modifican los flags. No hay que pensar que las instrucciones de salto condicional dependen de este repertorio, ya que lo único que hace el salto condicional es consultar los flags y salta si precede, pero no depende de ninguna instrucción de comparación. (de hecho cualquier operación aritmética realizada anteriormente a un salto condicional puede provocar que este "salte").
Nemotécnicos más frecuentes
•	compare: resta los dos operandos pero no almacena el resultado, solo modifica los flags.
•	test: compara un cierto valor especificado con el 0.
Instrucciones lógicas[editar]
Realizan operaciones booleanas "bit a bit" entre dos operandos. Como las aritméticas también modifican los flags.
Nemotécnicos más frecuentes
•	and: el "y" lógico.
•	or: el "o inclusivo" lógico.
•	xor: el "o exclusivo" lógico.
•	not: la negación lógica. (complemento a 1, no confundir con el cambio de signo "negate" que es el complemento a 2).
Instrucciones de desplazamiento[editar]
Pueden ser aritmético o lógico y pueden incluir o no rotaciones. Pueden ser de izquierda a derecha.
Nemotécnicos más frecuentes
•	shift: desplazamiento aritmético o lógico.
•	rotate: rotación con o sin acarreo.
Instrucciones de bits[editar]
Comprueban un bit del operando y su valor lo reflejan en el indicador de cero. Pueden poner un bit a 0 o complementarlo.
Nemotécnicos más frecuentes
•	bit test: comprueba un bit.
•	bit clear: comprueba un bit y lo pone a 0.
•	bit set: comprueba un bit y lo pone a 1.
Instrucciones de control[editar]
Permiten modificar la secuencia normal de ejecución de un programa, puede hacerse por salto condicional relativo o absoluto.
Se clasifican en cuatro grupos:
1.	salto incondicional
2.	salto condicional
3.	llamada a subrutinas
4.	gestión de las interrupciones
Saltos[editar]
Pueden ser condicionales o incondicionales, se suelen especificar como jump o branch, y en el caso de los condicionales se suele llamar jcond o bcond, donde cond es una o más letras que indican la condición que ha de cumplirse para que el salto se produzca.
Incondicional
Salta sin comprobar ninguna condición.
Nemotécnicos más frecuentes: jump o branch.
Condicional
Salta si la condición se cumple.
Nemotécnicos más frecuentes: jcond o bcond.
Llamadas a subrutinas[editar]
Invoca la ejecución de funciones anteriormente definidas.
Nemotécnicos más frecuentes: call (llamada) y ret (retorno).
Gestión de interrupciones[editar]
Se usan para llamar a las rutinas de servicio de interrupción y esto se puede hacer por hardware o bien por software. Necesita una instrucción similar a return para retornar al contexto anterior pero restableciendo el estado de la máquina, para no afectar a la aplicación a la cual se interrumpió (iret).
Instrucciones de entrada y salida[editar]
Son instrucciones de transferencia salvo que el origen/destino de dicho flujo es un puerto de un dispositivo de entrada y salida. Estas instrucciones pueden darse mediante dos alternativas:
1.	E/S "mapeada" en memoria: los periféricos tienen direcciones asignadas de la MP por lo que no se necesitan instrucciones especiales y las operaciones se realizan con las ya vistas, como son: load, store y move.
2.	E/S independiente: necesitan unas instrucciones especiales para indicarle al procesador que nos estamos refiriendo al mapa de direcciones de E/S, ya que este mapa y el mapa de memoria son disjuntos.
Nemotécnicos más frecuentes
•	input o read: permite leer información de un puerto y trasladarla a memoria principal.
•	output o write: permite escribir información en un puerto de un dispositivo.
•	test i/o: lee información de control de un periférico.
•	control i/o: envía información de control hacia un periférico.
Instrucciones de control y misceláneas[editar]
Nemoténicos más frecuentes:
•	halt: detiene la ejecución del programa hasta que una interrupción arranca otro programa.
•	wait: sirve para detener la ejecución de un programa hasta que sucede un determinado evento que no es una interrupción (otra condición externa al primer programa).
•	nop: no realiza ninguna operación, sirve para rellenar huecos en un programa o temporizar esperas.
•	enable: habilita las interrupciones.
•	disable: deshabilita las interrupciones.
•	test and set: se utiliza para la implementación de la exclusión mutua, esto es, que un procesador no pueda acceder a un determinado recurso que está siendo usado por otro procesador en ese mismo momento.
Se usan como semáforos, esto es, se declara una variable entera que tendrá el valor 0 si el recurso esta libre y 1 si está siendo utilizado, de manera que si un procesador comprueba y el semáforo está en 1 tendrá que esperar hasta que este cambie a 0 (1 = semáforo rojo y 0 = semáforo verde).
Véase también[editar]
•	[[Arquitectura
•	Arquitectura Intel Itanium
•	PowerPC
•	[[IBM
•	x86
•	IA-32
•	[
La familia x86 reagrupa los microprocesadores compatibles con el juego de instrucciones Intel 8086. Por tanto, x86 representa a ese conjunto de instrucciones, siendo también una denominación genérica dada a los correspondientes microprocesadores.
 
Índice
•	1Visión general
•	2Historia
o	2.1Intel
o	2.2Cronología
	2.2.1Predecesores (las raíces de la arquitectura x86)
	2.2.2Microprocesadores de la arquitectura x86
	2.2.3Sucesores (microprocesadores x86-64)
o	2.3x86-64
•	3Curiosidades
o	3.1Terminación numérica (Intel)
•	4Procesadores x86
o	4.1Intel
o	4.2AMD
o	4.3Cyrix
•	5Véase también
Visión general[editar]
La arquitectura es notablemente no limpia, por mantener compatibilidad con la línea de procesadores de 16 bits de Intel, que a su vez también eran compatibles con una familia de procesadores de 8 bits. A pesar de ello, la popularidad comercial de esta arquitectura hizo que muchos fabricantes empezaran a fabricar en masa microprocesadores compatibles. Algunas de estas compañías son AMD, Cyrix, NEC Corporation y Transmeta.
Existen dos sucesores de 64 bits para esta arquitectura:
•	IA64, empleada en los procesadores Itanium de Intel y no compatible con X86, excepto bajo emulación.
•	AMD64 o x86-64, de AMD, que es básicamente una extensión de 64 bits de la familia x86.
Técnicamente, la arquitectura es denominada IA32 (Intel Architecture 32 bits). Está basada en un modelo de arquitectura CISC (del inglés Complex Instruction Set Computing).
Historia[editar]
Intel[editar]
Intel inició sus operaciones siendo un fabricante de memoria para computadoras. En 1971 fue la primera compañía en lograr la integración de suficientes transistores como para vender un microprocesador programable completo con un conjunto de instrucciones de 4 bits, que se volvería muy común en calculadoras de bolsillo: El Intel 4004.
Al 4004 lo sucedieron el 8008 en 1972 y en 1974 el 8080, cada vez logrando mayor capacidad. En 1978, Intel comenzó a comercializar el procesador 8086, un ambicioso chip de 16 bits potencialmente capaz de ser el corazón de computadoras de propósito múltiple. El 8086 se comercializó en versiones desde 4,77 y hasta 10 MHz.
IBM adoptó al hermano menor del 8086 (el 8088, un procesador con un bus de datos interno de 16 bits, pero con el bus externo de 8 bits, lo que permitía aprovechar diseños y circuitos para sistemas de 8 bits) para basarse en él y lanzar la línea de computadoras más exitosa de la historia: el IBM PC (1981) y el IBM XT (eXtended Technology) (1983) (ver influencia del IBM PC).
El éxito de esta serie fue tal que a partir de ese momento, todos los CPUs de Intel mantuvieron una estricta política de retrocompatibilidad - Todo CPU fabricado por Intel desde ese momento y hasta el 2021 es capaz de ejecutar código compilado para cualquiera de sus predecesores.
Al 8086 lo sucedió el 80286 en 1982 (en el cual se basó la IBM PC/AT, 1985). Este chip, de 24/16 bits, implementó el modo protegido de ejecución, sentando las bases para la aparición de los verdaderos sistemas multitarea de escritorio. El 80286 apareció a 6 MHz, y a lo largo de los años llegó hasta los 12MHz. Hubo varios sistemas operativos que aprovecharon su modo protegido para ofrecer multitarea real, tales como las primeras versiones de OS/2, o Xenix.
Pero el verdadero boom de la multitarea no llegó hasta el nacimiento del 80386 (1985) - Un avance tan fuerte que hoy en día es común referirse como i386 a toda la línea de procesadores que le siguieron (también es común la referencia IA32, Intel Architecture of 32 bits). El 386 fue el primer procesador de Intel de 32 bits, y -magníficas noticias para los desarrolladores- utilizarlo para aplicaciones de multitarea sería ya mucho más fácil de lo que lo fue con el 80286. El 80386 maneja velocidades de 16 a 33 MHz.
El 80486 apareció en 1989. Fue un cambio relativamente menor frente al 80386 - Hasta su aparición, todas las computadoras PC tenían la opción de instalar en un zócalo de la placa base un -bastante caro- coprocesador numérico - para las XT, el 8087. Para las AT, el 80287. Para las 386, el 80387. A partir del 80486, el coprocesador numérico, así como la memoria caché L1 o de nivel 1 fueron integrados dentro del chip de la CPU (el coprocesador solo en los modelos 486DX, los modelos 486SX lo tenían desactivado), trayendo como resultado un gran aumento en la velocidad percibida por los usuarios. Internamente este procesador es el primer x86 segmentado (con una profundidad 5). Este cambio es importante pues permite a la misma frecuencia de reloj ejecutar casi el doble de instrucciones (1,9) e incrementar la frecuencia de reloj. El 486 existe en versiones desde 20 y hasta 100 MHz. Estos últimos denominados 486-DX4 a pesar de multiplicar por tres la frecuencia de funcionamiento interna respecto al bus de datos externo.
En 1993 apareció el Pentium. No se siguió con la nomenclatura 80586 porque muchas empresas competidoras de Intel habían comenzado a producir CPUs con el mismo número que los de Intel. Ante el hecho de que un número no puede ser usado como marca registrada, los procesadores llevan un nombre propio. Este procesador incorporaba bastantes novedades, entre ellas un coprocesador muy mejorado y un doble sistema de "prefetch", lo que le permitía en ciertas situaciones ejecutar dos instrucciones simultáneas, con el consiguiente aumento de rendimiento (esto solo era posible bajo ciertas combinaciones muy estrictas de instrucciones, con lo que el aumento de rendimiento solo era apreciable en aplicaciones compiladas específicamente para él). El Pentium llegó desde los 60 hasta los 233 MHz.
Poco después hizo su aparición el Pentium Pro, una versión orientada a servidores que incluía la caché de segundo nivel en el mismo encapsulado que el procesador. Su elevado precio supuso un freno a su expansión, pero luego su arquitectura P6 fue aprovechada para el Pentium II.[cita requerida]
Desde entonces, la tendencia al aparecer el Pentium II (1997), Pentium III (1999) y Pentium 4 (2000) ha sido la integración de más componentes, la adición de instrucciones específicas de multimedia y a elevar la velocidad de reloj tanto como sea posible. El Pentium II llegó desde 233 hasta 450 MHz. El Pentium III desde 450 a 1400 (1,4 GHz). El Pentium 4 debutó a 1,3 GHz y en noviembre del 2005 llegaba ya a los 3,80 GHz. Con todo, la carrera de los MHz se vio frenada debido al creciente consumo de energía y generación de calor producida por los microprocesadores a altas frecuencias de reloj, que en los últimos Pentium 4 superó fácilmente los 100 W.
Paralelamente al Pentium II dos familias de CPUs fueron anunciadas: El Celeron, que es similar a los Pentium pero con menos memoria caché y, por consiguiente, menor precio y prestaciones, y el Xeon, orientado a servidores, con más memoria caché - y claro está, de mucho mayor costo. Con los Celerón se continuó con una tendencia, ya iniciada en los 386 y 486, de tener dos modelos de diferentes prestaciones en la misma familia de procesadores: los modelos DX (386DX y 486DX), de mayores prestaciones, y los modelos SX (386SX y 486SX) de menores prestaciones. En el caso del 386SX por tener un bus externo de 16 bits en lugar de los 32 bits del 386DX, y en los 486SX por tener desactivado el coprocesador matemático interno. Así, en los Pentium II, Pentium III y Pentium 4 aparecieron sus correspondientes versiones de bajo costo y prestaciones (básicamente, como ya se ha dicho, por tener menos memoria caché de nivel 2) con el nombre comercial de Celeron. Parece ser que el motivo principal de dicha diversificación, aparte de aumentar a un costo mínimo el abanico de modelos, prestaciones y precios, es de marketing: debido a las constantes bajadas de precio que experimentan los procesadores y el hardware en general, crear una "barrera de contención" que justifique los diferentes niveles de precios, poniendo un precio más alto a los procesadores más potentes.
Cronología[editar]
Predecesores (las raíces de la arquitectura x86)[editar]
•	1971 Datapoint 2200. Terminal de computadora programable. Su conjunto de instrucciones es la base de los procesadores Intel desde el 8008 al 8085, los cuales a su vez son los antecesores de la arquitectura x86
•	1972 Intel 8008
•	1974 Intel 8080
•	1977 Intel 8085
1.	No se incluyen todos los microprocesadores
Microprocesadores de la arquitectura x86[editar]
•	1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
•	1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
•	1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
•	1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
•	1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
•	1985 Intel 80386. Primer microprocesador x86 de 32 bits.
•	1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
•	1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
•	1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
•	1996 Amd k5. Rival directo del Intel Pentium.
•	1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
•	1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
•	1999 Intel Pentium III. Introducción de las instrucciones SSE
•	2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
•	2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv
•	2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en hardware incluyendo x86-64 y SSSE3.
1.	No se incluyen todos los microprocesadores.
Sucesores (microprocesadores x86-64)[editar]
•	2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
1.	No se incluyen todos los microprocesadores
x86-64[editar]
Artículo principal: X86-64
Con la octava generación de procesadores compatibles x86, los x86-64, que utilizan arquitectura y bus de 64 bits, con posibilidad de múltiples núcleos, introducida por AMD y adoptadas por Intel, se introducen por primera vez nuevas variantes y formas, en lo que a la denominación y clasificación del procesador se refiere, tales como el nombre comercial o tecnología del modelo, la compañía fabricante, su número de serie, la cantidad de bits a la que puede trabajar o la cantidad de núcleos por los que está compuesto, por ejemplo: Intel Core 2 Duo E2180, o lo que es lo mismo, i686 o Intel Pentium de doble núcleo E2180, de 64 bits y de 1,6 a 2,0 GHz; o AMD Athlon 64 X2, es decir, un AMD 64 bits, Athlon X de doble núcleo a 2 GHz; todos ellos englobados bajo el denominador común x86-64, y compatibles con subarquitecturas anteriores de 32, 16 y 8 bits, de la familia de procesadores x86 de Intel, y compatibles.
Curiosidades[editar]
 	Las secciones de curiosidades deben ser evitadas.
Puedes mejorar este artículo introduciendo la información útil de esta sección en el resto del texto y quitando los datos inapropiados.
Terminación numérica (Intel)[editar]
 
Microprocesador Intel D8086
Se utilizaba el número 86 en la terminación numérica de algunos microprocesadores de la familia Intel, por ejemplo D8086, para indicar que utilizaban la arquitectura o conjunto de instrucciones x86. Constituyeron desde su nacimiento un estándar para los ordenadores del tipo Compatible IBM PC.
A partir del microprocesador i486, se utilizaron nombres no numéricos, haciendo referencia a la marca, logotipo o nombre clave con los que fueron lanzados al mercado, y se les comercializó a menudo seguido de su frecuencia, en megahertz.
Procesadores x86[editar]
Intel[editar]
•	486SX
•	486DX
•	486DX2
•	486DX4
•	Pentium
•	Pentium II
•	Pentium Pro
•	Pentium III
•	Pentium 4
•	Pentium D
•	Core 2 Quad
•	Core 2 Duo
•	Core i3
•	Core i5
•	Core i7
•	Core i9
AMD[editar]
•	K5
•	K6
•	K7 (Athlon, Athlon XP)
•	Duron
•	Sempron
•	Ryzen
Cyrix[editar]
6x86
1.	No se incluyen todos los procesadores x86.
Véase también[editar]
•	Lenguaje ensamblador x86
•	Anexo:Listados de instrucciones x86
•	Serie de coprocesadores numéricos x87
Control de autoridades
•	Proyectos Wikimedia
•	  Datos: Q182933
•	  Multimedia: X86 M

n informática, Hola mundo es un programa que muestra el texto «¡Hola, mundo!» en un dispositivo de visualización, en la mayoría de los casos la pantalla de un monitor. Este programa suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico, y se considera fundamental desde el punto de vista didáctico.
En algunos lenguajes, configurar un conjunto de herramientas básicas completo desde cero hasta el punto en que los programas triviales puedan ser compilados y ejecutados involucra una cantidad de trabajo sustancial. Por esta razón, generalmente es usado un programa muy simple para probar un nuevo conjunto de herramientas.
En los sistemas basados en microcontroladores empleados para el aprendizaje, se suele considerar Hola mundo el programa que permite poner en modo intermitente un led.1 El programa consiste en mandar alternativamente un nivel alto y uno bajo por uno de los puertos del sistema, dando a cada uno de dichos niveles un valor de retardo.
El primer ejemplo documentado de un programa Hola Mundo fue en 1973, en la obra A tutorial introduction to the language B, de Brian Kernighan.2
Un microcontrolador (abreviado µC, UC o mCU) es un circuito integrado programable, capaz de ejecutar las órdenes grabadas en su memoria. Está compuesto de varios bloques funcionales que cumplen una tarea específica. Un microcontrolador incluye en su interior las tres principales unidades funcionales de una computadora: unidad central de procesamiento, memoria y periféricos de entrada/salida.
Algunos microcontroladores pueden utilizar palabras de cuatro bits y funcionan a velocidad de reloj con frecuencias tan bajas como 4 kHz, con un consumo de baja potencia (mW o microwatts). Por lo general, tendrá la capacidad de mantenerse a la espera de un evento como pulsar un botón o de otra interrupción; así, el consumo de energía durante el estado de reposo (reloj de la CPU y los periféricos de la mayoría) puede ser solo de nanowatts, lo que hace que muchos de ellos sean muy adecuados para aplicaciones con batería de larga duración. Otros microcontroladores pueden servir para roles de rendimiento crítico, donde sea necesario actuar más como un procesador digital de señal (DSP), con velocidades de reloj y consumo de energía más altos.
Cuando es fabricado el microcontrolador, no contiene datos en la memoria ROM. Para que pueda controlar algún proceso es necesario generar o crear y luego grabar en la EEPROM o equivalente del microcontrolador algún programa, el cual puede ser escrito en lenguaje ensamblador u otro lenguaje para microcontroladores; sin embargo, para que el programa pueda ser grabado en la memoria del microcontrolador, debe ser codificado en sistema numérico hexadecimal que es finalmente el sistema que hace trabajar al microcontrolador cuando este es alimentado con el voltaje adecuado y asociado a dispositivos analógicos y discretos para su funcionamiento.1
El primer microprocesador fue el Intel 4004 de 4 bits, lanzado en 1971, seguido por el Intel 8008 y otros más capaces. Sin embargo, ambos procesadores requieren circuitos adicionales para implementar un sistema de trabajo, elevando el costo del sistema total.
El Instituto Smithsoniano dice que los ingenieros de Texas Instruments Gary Boone y Michael Cochran lograron crear el primer microcontrolador, TMS 1000, en 1971; fue comercializado en 1974. Combina memoria ROM, memoria RAM, microprocesador y reloj en un chip y estaba destinada a los sistemas embebidos.2
Debido en parte a la existencia del TMS 1000,3 Intel desarrolló un sistema de ordenador en un chip optimizado para aplicaciones de control, el Intel 8048, que comenzó a comercializarse en 1977.3 Combina memoria RAM y ROM en el mismo chip y puede encontrarse en más de mil millones de teclados de compatible IBM PC, y otras numerosas aplicaciones. El en ese momento presidente de Intel, Luke J. Valenter, declaró que el microcontrolador es uno de los productos más exitosos en la historia de la compañía, y amplió el presupuesto de la división en más del 25%.
La mayoría de los microcontroladores en aquel momento tenían dos variantes. Unos tenían una memoria EPROM reprogramable, significativamente más caros que la variante PROM que era solo una vez programable. Para borrar la EPROM necesita exponer a la luz ultravioleta la tapa de cuarzo transparente. Los chips con todo opaco representaban un coste menor.
En 1993, el lanzamiento de la EEPROM en los microcontroladores (comenzando con el Microchip PIC16x84)4 permite borrarla eléctrica y rápidamente sin necesidad de un paquete costoso como se requiere en EPROM, lo que permite tanto la creación rápida de prototipos y la programación en el sistema. El mismo año, Atmel lanza el primer microcontrolador que utiliza memoria flash.5 Otras compañías rápidamente siguieron el ejemplo, con los dos tipos de memoria.
El costo se ha desplomado en el tiempo, con el más barato microcontrolador de 8 bits disponible por menos de 0,25 dólares para miles de unidades en 2009, y algunos microcontroladores de 32 bits a 1 dólar por cantidades similares. En la actualidad los microcontroladores son baratos y fácilmente disponibles para los aficionados, con grandes comunidades en línea para ciertos procesadores.
En el futuro, la MRAM podría ser utilizada en microcontroladores, ya que tiene resistencia infinita y el coste de su oblea semiconductora es relativamente bajo.
Los microcontroladores están diseñados para reducir el costo económico y el consumo de energía de un sistema en particular. Por eso el tamaño de la unidad central de procesamiento, la cantidad de memoria y los periféricos incluidos dependerán de la aplicación. El control de un electrodoméstico sencillo como una batidora utilizará un procesador muy pequeño (4 u 8 bits) porque sustituirá a un autómata finito. En cambio, un reproductor de música o vídeo digital (MP3 o MP4) requerirá de un procesador de 32 bits o de 64 bits y de uno o más códecs de señal digital (audio o vídeo). El control de un sistema de frenos ABS (Antilock Brake System) se basa normalmente en un microcontrolador de 16 bits, al igual que el sistema de control electrónico del motor en un automóvil.
Los microcontroladores representan la inmensa mayoría de los chips de computadoras vendidos, sobre un 50% son controladores "simples" y el restante corresponde a DSP más especializados. Mientras se pueden tener uno o dos microprocesadores de propósito general en casa (Ud. está usando uno para esto), usted tiene distribuidos seguramente entre los electrodomésticos de su hogar una o dos docenas de microcontroladores. Pueden encontrarse en casi cualquier dispositivo electrónico como automóviles, lavadoras, hornos microondas, teléfonos, etc.
Un microcontrolador difiere de una unidad central de procesamiento normal, debido a que es más fácil convertirla en una computadora en funcionamiento, con un mínimo de circuitos integrados externos de apoyo. La idea es que el circuito integrado se coloque en el dispositivo, enganchado a la fuente de energía y de información que necesite, y eso es todo. Un microprocesador tradicional no le permitirá hacer esto, ya que espera que todas estas tareas sean manejadas por otros chips. Hay que agregarle los módulos de entrada y salida (puertos) y la memoria para almacenamiento de información.
Un microcontrolador típico tendrá un generador de reloj integrado y una pequeña cantidad de memoria de acceso aleatorio o ROM/EPROM/EEPROM/flash, con lo que para hacerlo funcionar todo lo que se necesita son unos pocos programas de control y un cristal de sincronización. Los microcontroladores disponen generalmente también de una gran variedad de dispositivos de entrada/salida, como convertidor analógico digital, temporizadores, UARTs y buses de interfaz serie especializados, como I2C y CAN. Frecuentemente, estos dispositivos integrados pueden ser controlados por instrucciones de procesadores especializados. Los modernos microcontroladores frecuentemente incluyen un lenguaje de programación integrado, como el lenguaje de programación BASIC que se utiliza bastante con este propósito.
Los microcontroladores negocian la velocidad y la flexibilidad para facilitar su uso. Debido a que se utiliza bastante sitio en el chip para incluir funcionalidad, como los dispositivos de entrada/salida o la memoria que incluye el microcontrolador, se ha de prescindir de cualquier otra circuitería.
Arquitecturas de computadora[editar]
Artículo principal: Arquitectura de computadoras
Básicamente existen dos arquitecturas de computadoras, y por supuesto, están presentes en el mundo de los microcontroladores: Von Neumann y Harvard. Ambas se diferencian en la forma de conexión de la memoria al procesador y en los buses que cada una necesita.
Arquitectura Von Neumann[editar]
Artículo principal: Arquitectura Von Neumann
La arquitectura Von Neumann utiliza el mismo dispositivo de almacenamiento tanto para las instrucciones como para los datos, siendo la que se utiliza en un ordenador personal porque permite ahorrar una buena cantidad de líneas de E/S, que son bastante costosas, sobre todo para aquellos sistemas donde el procesador se monta en algún tipo de zócalo alojado en una placa madre. También esta organización les ahorra a los diseñadores de placas madre una buena cantidad de problemas y reduce el costo de este tipo de sistemas.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
En el caso de los microcontroladores, existen dos tipos de memoria bien definidas: memoria de datos (típicamente algún tipo de SRAM) y memoria de programas (ROM, PROM, EEPROM, flash u de otro tipo no volátil). En este caso la organización es distinta a las del ordenador personal, porque hay circuitos distintos para cada memoria y normalmente no se utilizan los registros de segmentos, sino que la memoria está segregada y el acceso a cada tipo de memoria depende de las instrucciones del procesador.
A pesar de que en los sistemas integrados con arquitectura Von Neumann la memoria esté segregada, y existan diferencias con respecto a la definición tradicional de esta arquitectura; los buses para acceder a ambos tipos de memoria son los mismos, del procesador solamente salen el bus de datos, el de direcciones, y el de control. Como conclusión, la arquitectura no ha sido alterada, porque la forma en que se conecta la memoria al procesador sigue el mismo principio definido en la arquitectura básica.
Algunas familias de microcontroladores como la Intel 8051 y la Z80 implementan este tipo de arquitectura, fundamentalmente porque era la utilizada cuando aparecieron los primeros microcontroladores.
Arquitectura Harvard[editar]
Artículo principal: Arquitectura Harvard
La otra variante es la arquitectura Harvard, y por excelencia la utilizada en supercomputadoras, en los microcontroladores, y sistemas integrados en general. En este caso, además de la memoria, el procesador tiene los buses segregados, de modo que cada tipo de memoria tiene un bus de datos, uno de direcciones y uno de control.
En un ordenador personal, cuando se carga un programa en memoria, a este se le asigna un espacio de direcciones de la memoria que se divide en segmentos, de los cuales típicamente tendremos los siguientes: código (programa), datos y pila. Es por ello que podemos hablar de la memoria como un todo, aunque existan distintos dispositivos físicos en el sistema (disco duro, memoria RAM, memoria flash, unidad de disco óptico…).
